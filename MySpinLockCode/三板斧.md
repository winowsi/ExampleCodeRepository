# 自旋锁（spin_lock）



#### 1.什么是自旋锁

###### 	1.自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

###### 	2.线程自旋是需要消耗cup的，说白了就是让cup在做无用功，如果一直获取不到锁，那线程也不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。**自旋周期**

###### 	3.如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。

#### 2.自旋锁的优点

###### 	1、尽可能减少线程阻塞，对于锁竞争不激烈，且占用锁的时间非常短的代码块来说性能提升非常大，因为自旋锁的消耗会小于线程阻塞再唤醒操作的消耗，这些操作会导致线程两次上下文的切换！

#### 3.自旋锁的缺点

###### 	1、如果业务代码占用锁的时间比较长，会导致CPU资源的浪费，加大CPU的消耗

#### 4.适用的场景

###### 	1、业务代码占用锁的时间非常短且锁竞争不激烈

#### 5不适用的场景

###### 	1、业务代码占用锁的时间长 且 锁竞争激烈

###### 			原因：因为自旋锁在获取锁前一直占用CPU做无用功，同时有大量线程竞争一把锁，会导致获取锁的时间很长 ，线程自旋的消耗大于线程阻塞挂起操作的消耗，其他线程的且不能获取到CPU，导致CPU的资源浪费 所以这这种场景不适合！

